// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"rtc/internal/storage"

	mock "github.com/stretchr/testify/mock"
)

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

type MockStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStorage) EXPECT() *MockStorage_Expecter {
	return &MockStorage_Expecter{mock: &_m.Mock}
}

// AddAuditRecord provides a mock function for the type MockStorage
func (_mock *MockStorage) AddAuditRecord(ctx context.Context, audit *storage.Audit) error {
	ret := _mock.Called(ctx, audit)

	if len(ret) == 0 {
		panic("no return value specified for AddAuditRecord")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.Audit) error); ok {
		r0 = returnFunc(ctx, audit)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_AddAuditRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAuditRecord'
type MockStorage_AddAuditRecord_Call struct {
	*mock.Call
}

// AddAuditRecord is a helper method to define mock.On call
//   - ctx context.Context
//   - audit *storage.Audit
func (_e *MockStorage_Expecter) AddAuditRecord(ctx interface{}, audit interface{}) *MockStorage_AddAuditRecord_Call {
	return &MockStorage_AddAuditRecord_Call{Call: _e.mock.On("AddAuditRecord", ctx, audit)}
}

func (_c *MockStorage_AddAuditRecord_Call) Run(run func(ctx context.Context, audit *storage.Audit)) *MockStorage_AddAuditRecord_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.Audit
		if args[1] != nil {
			arg1 = args[1].(*storage.Audit)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_AddAuditRecord_Call) Return(err error) *MockStorage_AddAuditRecord_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_AddAuditRecord_Call) RunAndReturn(run func(ctx context.Context, audit *storage.Audit) error) *MockStorage_AddAuditRecord_Call {
	_c.Call.Return(run)
	return _c
}

// AuditsSearch provides a mock function for the type MockStorage
func (_mock *MockStorage) AuditsSearch(ctx context.Context, filter storage.AuditFilter) ([]*storage.Audit, error) {
	ret := _mock.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for AuditsSearch")
	}

	var r0 []*storage.Audit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, storage.AuditFilter) ([]*storage.Audit, error)); ok {
		return returnFunc(ctx, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, storage.AuditFilter) []*storage.Audit); ok {
		r0 = returnFunc(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Audit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, storage.AuditFilter) error); ok {
		r1 = returnFunc(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_AuditsSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuditsSearch'
type MockStorage_AuditsSearch_Call struct {
	*mock.Call
}

// AuditsSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - filter storage.AuditFilter
func (_e *MockStorage_Expecter) AuditsSearch(ctx interface{}, filter interface{}) *MockStorage_AuditsSearch_Call {
	return &MockStorage_AuditsSearch_Call{Call: _e.mock.On("AuditsSearch", ctx, filter)}
}

func (_c *MockStorage_AuditsSearch_Call) Run(run func(ctx context.Context, filter storage.AuditFilter)) *MockStorage_AuditsSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 storage.AuditFilter
		if args[1] != nil {
			arg1 = args[1].(storage.AuditFilter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_AuditsSearch_Call) Return(audits []*storage.Audit, err error) *MockStorage_AuditsSearch_Call {
	_c.Call.Return(audits, err)
	return _c
}

func (_c *MockStorage_AuditsSearch_Call) RunAndReturn(run func(ctx context.Context, filter storage.AuditFilter) ([]*storage.Audit, error)) *MockStorage_AuditsSearch_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function for the type MockStorage
func (_mock *MockStorage) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockStorage_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockStorage_Expecter) Close() *MockStorage_Close_Call {
	return &MockStorage_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockStorage_Close_Call) Run(run func()) *MockStorage_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStorage_Close_Call) Return(err error) *MockStorage_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_Close_Call) RunAndReturn(run func() error) *MockStorage_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Config provides a mock function for the type MockStorage
func (_mock *MockStorage) Config(ctx context.Context, projectName string, envName string, releaseName string, key string) (*storage.Config, error) {
	ret := _mock.Called(ctx, projectName, envName, releaseName, key)

	if len(ret) == 0 {
		panic("no return value specified for Config")
	}

	var r0 *storage.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (*storage.Config, error)); ok {
		return returnFunc(ctx, projectName, envName, releaseName, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) *storage.Config); ok {
		r0 = returnFunc(ctx, projectName, envName, releaseName, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.Config)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectName, envName, releaseName, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Config_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Config'
type MockStorage_Config_Call struct {
	*mock.Call
}

// Config is a helper method to define mock.On call
//   - ctx context.Context
//   - projectName string
//   - envName string
//   - releaseName string
//   - key string
func (_e *MockStorage_Expecter) Config(ctx interface{}, projectName interface{}, envName interface{}, releaseName interface{}, key interface{}) *MockStorage_Config_Call {
	return &MockStorage_Config_Call{Call: _e.mock.On("Config", ctx, projectName, envName, releaseName, key)}
}

func (_c *MockStorage_Config_Call) Run(run func(ctx context.Context, projectName string, envName string, releaseName string, key string)) *MockStorage_Config_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStorage_Config_Call) Return(config *storage.Config, err error) *MockStorage_Config_Call {
	_c.Call.Return(config, err)
	return _c
}

func (_c *MockStorage_Config_Call) RunAndReturn(run func(ctx context.Context, projectName string, envName string, releaseName string, key string) (*storage.Config, error)) *MockStorage_Config_Call {
	_c.Call.Return(run)
	return _c
}

// Configs provides a mock function for the type MockStorage
func (_mock *MockStorage) Configs(ctx context.Context, projectName string, envName string, releaseName string) ([]*storage.Config, error) {
	ret := _mock.Called(ctx, projectName, envName, releaseName)

	if len(ret) == 0 {
		panic("no return value specified for Configs")
	}

	var r0 []*storage.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) ([]*storage.Config, error)); ok {
		return returnFunc(ctx, projectName, envName, releaseName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) []*storage.Config); ok {
		r0 = returnFunc(ctx, projectName, envName, releaseName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Config)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectName, envName, releaseName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Configs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Configs'
type MockStorage_Configs_Call struct {
	*mock.Call
}

// Configs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectName string
//   - envName string
//   - releaseName string
func (_e *MockStorage_Expecter) Configs(ctx interface{}, projectName interface{}, envName interface{}, releaseName interface{}) *MockStorage_Configs_Call {
	return &MockStorage_Configs_Call{Call: _e.mock.On("Configs", ctx, projectName, envName, releaseName)}
}

func (_c *MockStorage_Configs_Call) Run(run func(ctx context.Context, projectName string, envName string, releaseName string)) *MockStorage_Configs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_Configs_Call) Return(configs []*storage.Config, err error) *MockStorage_Configs_Call {
	_c.Call.Return(configs, err)
	return _c
}

func (_c *MockStorage_Configs_Call) RunAndReturn(run func(ctx context.Context, projectName string, envName string, releaseName string) ([]*storage.Config, error)) *MockStorage_Configs_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigsByKeys provides a mock function for the type MockStorage
func (_mock *MockStorage) ConfigsByKeys(ctx context.Context, projectName string, envName string, releaseName string, keys []string) ([]*storage.Config, error) {
	ret := _mock.Called(ctx, projectName, envName, releaseName, keys)

	if len(ret) == 0 {
		panic("no return value specified for ConfigsByKeys")
	}

	var r0 []*storage.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, []string) ([]*storage.Config, error)); ok {
		return returnFunc(ctx, projectName, envName, releaseName, keys)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, []string) []*storage.Config); ok {
		r0 = returnFunc(ctx, projectName, envName, releaseName, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Config)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, []string) error); ok {
		r1 = returnFunc(ctx, projectName, envName, releaseName, keys)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_ConfigsByKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigsByKeys'
type MockStorage_ConfigsByKeys_Call struct {
	*mock.Call
}

// ConfigsByKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - projectName string
//   - envName string
//   - releaseName string
//   - keys []string
func (_e *MockStorage_Expecter) ConfigsByKeys(ctx interface{}, projectName interface{}, envName interface{}, releaseName interface{}, keys interface{}) *MockStorage_ConfigsByKeys_Call {
	return &MockStorage_ConfigsByKeys_Call{Call: _e.mock.On("ConfigsByKeys", ctx, projectName, envName, releaseName, keys)}
}

func (_c *MockStorage_ConfigsByKeys_Call) Run(run func(ctx context.Context, projectName string, envName string, releaseName string, keys []string)) *MockStorage_ConfigsByKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStorage_ConfigsByKeys_Call) Return(configs []*storage.Config, err error) *MockStorage_ConfigsByKeys_Call {
	_c.Call.Return(configs, err)
	return _c
}

func (_c *MockStorage_ConfigsByKeys_Call) RunAndReturn(run func(ctx context.Context, projectName string, envName string, releaseName string, keys []string) ([]*storage.Config, error)) *MockStorage_ConfigsByKeys_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEnvironment provides a mock function for the type MockStorage
func (_mock *MockStorage) CreateEnvironment(ctx context.Context, env *storage.Environment) error {
	ret := _mock.Called(ctx, env)

	if len(ret) == 0 {
		panic("no return value specified for CreateEnvironment")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.Environment) error); ok {
		r0 = returnFunc(ctx, env)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_CreateEnvironment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEnvironment'
type MockStorage_CreateEnvironment_Call struct {
	*mock.Call
}

// CreateEnvironment is a helper method to define mock.On call
//   - ctx context.Context
//   - env *storage.Environment
func (_e *MockStorage_Expecter) CreateEnvironment(ctx interface{}, env interface{}) *MockStorage_CreateEnvironment_Call {
	return &MockStorage_CreateEnvironment_Call{Call: _e.mock.On("CreateEnvironment", ctx, env)}
}

func (_c *MockStorage_CreateEnvironment_Call) Run(run func(ctx context.Context, env *storage.Environment)) *MockStorage_CreateEnvironment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.Environment
		if args[1] != nil {
			arg1 = args[1].(*storage.Environment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_CreateEnvironment_Call) Return(err error) *MockStorage_CreateEnvironment_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_CreateEnvironment_Call) RunAndReturn(run func(ctx context.Context, env *storage.Environment) error) *MockStorage_CreateEnvironment_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function for the type MockStorage
func (_mock *MockStorage) CreateProject(ctx context.Context, project *storage.Project) error {
	ret := _mock.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.Project) error); ok {
		r0 = returnFunc(ctx, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type MockStorage_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *storage.Project
func (_e *MockStorage_Expecter) CreateProject(ctx interface{}, project interface{}) *MockStorage_CreateProject_Call {
	return &MockStorage_CreateProject_Call{Call: _e.mock.On("CreateProject", ctx, project)}
}

func (_c *MockStorage_CreateProject_Call) Run(run func(ctx context.Context, project *storage.Project)) *MockStorage_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.Project
		if args[1] != nil {
			arg1 = args[1].(*storage.Project)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_CreateProject_Call) Return(err error) *MockStorage_CreateProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_CreateProject_Call) RunAndReturn(run func(ctx context.Context, project *storage.Project) error) *MockStorage_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRelease provides a mock function for the type MockStorage
func (_mock *MockStorage) CreateRelease(ctx context.Context, release *storage.Release) error {
	ret := _mock.Called(ctx, release)

	if len(ret) == 0 {
		panic("no return value specified for CreateRelease")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.Release) error); ok {
		r0 = returnFunc(ctx, release)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_CreateRelease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRelease'
type MockStorage_CreateRelease_Call struct {
	*mock.Call
}

// CreateRelease is a helper method to define mock.On call
//   - ctx context.Context
//   - release *storage.Release
func (_e *MockStorage_Expecter) CreateRelease(ctx interface{}, release interface{}) *MockStorage_CreateRelease_Call {
	return &MockStorage_CreateRelease_Call{Call: _e.mock.On("CreateRelease", ctx, release)}
}

func (_c *MockStorage_CreateRelease_Call) Run(run func(ctx context.Context, release *storage.Release)) *MockStorage_CreateRelease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.Release
		if args[1] != nil {
			arg1 = args[1].(*storage.Release)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_CreateRelease_Call) Return(err error) *MockStorage_CreateRelease_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_CreateRelease_Call) RunAndReturn(run func(ctx context.Context, release *storage.Release) error) *MockStorage_CreateRelease_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function for the type MockStorage
func (_mock *MockStorage) CreateUser(ctx context.Context, user *storage.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockStorage_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *storage.User
func (_e *MockStorage_Expecter) CreateUser(ctx interface{}, user interface{}) *MockStorage_CreateUser_Call {
	return &MockStorage_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *MockStorage_CreateUser_Call) Run(run func(ctx context.Context, user *storage.User)) *MockStorage_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.User
		if args[1] != nil {
			arg1 = args[1].(*storage.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_CreateUser_Call) Return(err error) *MockStorage_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_CreateUser_Call) RunAndReturn(run func(ctx context.Context, user *storage.User) error) *MockStorage_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConfigs provides a mock function for the type MockStorage
func (_mock *MockStorage) DeleteConfigs(ctx context.Context, IDs []uint64) error {
	ret := _mock.Called(ctx, IDs)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConfigs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []uint64) error); ok {
		r0 = returnFunc(ctx, IDs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_DeleteConfigs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConfigs'
type MockStorage_DeleteConfigs_Call struct {
	*mock.Call
}

// DeleteConfigs is a helper method to define mock.On call
//   - ctx context.Context
//   - IDs []uint64
func (_e *MockStorage_Expecter) DeleteConfigs(ctx interface{}, IDs interface{}) *MockStorage_DeleteConfigs_Call {
	return &MockStorage_DeleteConfigs_Call{Call: _e.mock.On("DeleteConfigs", ctx, IDs)}
}

func (_c *MockStorage_DeleteConfigs_Call) Run(run func(ctx context.Context, IDs []uint64)) *MockStorage_DeleteConfigs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []uint64
		if args[1] != nil {
			arg1 = args[1].([]uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_DeleteConfigs_Call) Return(err error) *MockStorage_DeleteConfigs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_DeleteConfigs_Call) RunAndReturn(run func(ctx context.Context, IDs []uint64) error) *MockStorage_DeleteConfigs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function for the type MockStorage
func (_mock *MockStorage) DeleteProject(ctx context.Context, ID uint64) error {
	ret := _mock.Called(ctx, ID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64) error); ok {
		r0 = returnFunc(ctx, ID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type MockStorage_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - ctx context.Context
//   - ID uint64
func (_e *MockStorage_Expecter) DeleteProject(ctx interface{}, ID interface{}) *MockStorage_DeleteProject_Call {
	return &MockStorage_DeleteProject_Call{Call: _e.mock.On("DeleteProject", ctx, ID)}
}

func (_c *MockStorage_DeleteProject_Call) Run(run func(ctx context.Context, ID uint64)) *MockStorage_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_DeleteProject_Call) Return(err error) *MockStorage_DeleteProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_DeleteProject_Call) RunAndReturn(run func(ctx context.Context, ID uint64) error) *MockStorage_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRelease provides a mock function for the type MockStorage
func (_mock *MockStorage) DeleteRelease(ctx context.Context, envID uint64, releaseName string) error {
	ret := _mock.Called(ctx, envID, releaseName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRelease")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) error); ok {
		r0 = returnFunc(ctx, envID, releaseName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_DeleteRelease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRelease'
type MockStorage_DeleteRelease_Call struct {
	*mock.Call
}

// DeleteRelease is a helper method to define mock.On call
//   - ctx context.Context
//   - envID uint64
//   - releaseName string
func (_e *MockStorage_Expecter) DeleteRelease(ctx interface{}, envID interface{}, releaseName interface{}) *MockStorage_DeleteRelease_Call {
	return &MockStorage_DeleteRelease_Call{Call: _e.mock.On("DeleteRelease", ctx, envID, releaseName)}
}

func (_c *MockStorage_DeleteRelease_Call) Run(run func(ctx context.Context, envID uint64, releaseName string)) *MockStorage_DeleteRelease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_DeleteRelease_Call) Return(err error) *MockStorage_DeleteRelease_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_DeleteRelease_Call) RunAndReturn(run func(ctx context.Context, envID uint64, releaseName string) error) *MockStorage_DeleteRelease_Call {
	_c.Call.Return(run)
	return _c
}

// Environment provides a mock function for the type MockStorage
func (_mock *MockStorage) Environment(ctx context.Context, projectID uint64, envName string) (*storage.Environment, error) {
	ret := _mock.Called(ctx, projectID, envName)

	if len(ret) == 0 {
		panic("no return value specified for Environment")
	}

	var r0 *storage.Environment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) (*storage.Environment, error)); ok {
		return returnFunc(ctx, projectID, envName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) *storage.Environment); ok {
		r0 = returnFunc(ctx, projectID, envName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.Environment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, string) error); ok {
		r1 = returnFunc(ctx, projectID, envName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Environment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Environment'
type MockStorage_Environment_Call struct {
	*mock.Call
}

// Environment is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID uint64
//   - envName string
func (_e *MockStorage_Expecter) Environment(ctx interface{}, projectID interface{}, envName interface{}) *MockStorage_Environment_Call {
	return &MockStorage_Environment_Call{Call: _e.mock.On("Environment", ctx, projectID, envName)}
}

func (_c *MockStorage_Environment_Call) Run(run func(ctx context.Context, projectID uint64, envName string)) *MockStorage_Environment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_Environment_Call) Return(environment *storage.Environment, err error) *MockStorage_Environment_Call {
	_c.Call.Return(environment, err)
	return _c
}

func (_c *MockStorage_Environment_Call) RunAndReturn(run func(ctx context.Context, projectID uint64, envName string) (*storage.Environment, error)) *MockStorage_Environment_Call {
	_c.Call.Return(run)
	return _c
}

// Environments provides a mock function for the type MockStorage
func (_mock *MockStorage) Environments(ctx context.Context, projectName string) ([]*storage.Environment, error) {
	ret := _mock.Called(ctx, projectName)

	if len(ret) == 0 {
		panic("no return value specified for Environments")
	}

	var r0 []*storage.Environment
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*storage.Environment, error)); ok {
		return returnFunc(ctx, projectName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*storage.Environment); ok {
		r0 = returnFunc(ctx, projectName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Environment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, projectName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Environments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Environments'
type MockStorage_Environments_Call struct {
	*mock.Call
}

// Environments is a helper method to define mock.On call
//   - ctx context.Context
//   - projectName string
func (_e *MockStorage_Expecter) Environments(ctx interface{}, projectName interface{}) *MockStorage_Environments_Call {
	return &MockStorage_Environments_Call{Call: _e.mock.On("Environments", ctx, projectName)}
}

func (_c *MockStorage_Environments_Call) Run(run func(ctx context.Context, projectName string)) *MockStorage_Environments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Environments_Call) Return(environments []*storage.Environment, err error) *MockStorage_Environments_Call {
	_c.Call.Return(environments, err)
	return _c
}

func (_c *MockStorage_Environments_Call) RunAndReturn(run func(ctx context.Context, projectName string) ([]*storage.Environment, error)) *MockStorage_Environments_Call {
	_c.Call.Return(run)
	return _c
}

// MarkConfigsUpdated provides a mock function for the type MockStorage
func (_mock *MockStorage) MarkConfigsUpdated(ctx context.Context, IDs []uint64) error {
	ret := _mock.Called(ctx, IDs)

	if len(ret) == 0 {
		panic("no return value specified for MarkConfigsUpdated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []uint64) error); ok {
		r0 = returnFunc(ctx, IDs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_MarkConfigsUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkConfigsUpdated'
type MockStorage_MarkConfigsUpdated_Call struct {
	*mock.Call
}

// MarkConfigsUpdated is a helper method to define mock.On call
//   - ctx context.Context
//   - IDs []uint64
func (_e *MockStorage_Expecter) MarkConfigsUpdated(ctx interface{}, IDs interface{}) *MockStorage_MarkConfigsUpdated_Call {
	return &MockStorage_MarkConfigsUpdated_Call{Call: _e.mock.On("MarkConfigsUpdated", ctx, IDs)}
}

func (_c *MockStorage_MarkConfigsUpdated_Call) Run(run func(ctx context.Context, IDs []uint64)) *MockStorage_MarkConfigsUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []uint64
		if args[1] != nil {
			arg1 = args[1].([]uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_MarkConfigsUpdated_Call) Return(err error) *MockStorage_MarkConfigsUpdated_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_MarkConfigsUpdated_Call) RunAndReturn(run func(ctx context.Context, IDs []uint64) error) *MockStorage_MarkConfigsUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectByName provides a mock function for the type MockStorage
func (_mock *MockStorage) ProjectByName(ctx context.Context, name string) (*storage.Project, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for ProjectByName")
	}

	var r0 *storage.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*storage.Project, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *storage.Project); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_ProjectByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectByName'
type MockStorage_ProjectByName_Call struct {
	*mock.Call
}

// ProjectByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockStorage_Expecter) ProjectByName(ctx interface{}, name interface{}) *MockStorage_ProjectByName_Call {
	return &MockStorage_ProjectByName_Call{Call: _e.mock.On("ProjectByName", ctx, name)}
}

func (_c *MockStorage_ProjectByName_Call) Run(run func(ctx context.Context, name string)) *MockStorage_ProjectByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_ProjectByName_Call) Return(project *storage.Project, err error) *MockStorage_ProjectByName_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *MockStorage_ProjectByName_Call) RunAndReturn(run func(ctx context.Context, name string) (*storage.Project, error)) *MockStorage_ProjectByName_Call {
	_c.Call.Return(run)
	return _c
}

// Projects provides a mock function for the type MockStorage
func (_mock *MockStorage) Projects(ctx context.Context, q string, limit uint64, offset uint64) ([]*storage.Project, uint64, error) {
	ret := _mock.Called(ctx, q, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for Projects")
	}

	var r0 []*storage.Project
	var r1 uint64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64) ([]*storage.Project, uint64, error)); ok {
		return returnFunc(ctx, q, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64) []*storage.Project); ok {
		r0 = returnFunc(ctx, q, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint64, uint64) uint64); ok {
		r1 = returnFunc(ctx, q, limit, offset)
	} else {
		r1 = ret.Get(1).(uint64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, uint64, uint64) error); ok {
		r2 = returnFunc(ctx, q, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStorage_Projects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Projects'
type MockStorage_Projects_Call struct {
	*mock.Call
}

// Projects is a helper method to define mock.On call
//   - ctx context.Context
//   - q string
//   - limit uint64
//   - offset uint64
func (_e *MockStorage_Expecter) Projects(ctx interface{}, q interface{}, limit interface{}, offset interface{}) *MockStorage_Projects_Call {
	return &MockStorage_Projects_Call{Call: _e.mock.On("Projects", ctx, q, limit, offset)}
}

func (_c *MockStorage_Projects_Call) Run(run func(ctx context.Context, q string, limit uint64, offset uint64)) *MockStorage_Projects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_Projects_Call) Return(projects []*storage.Project, v uint64, err error) *MockStorage_Projects_Call {
	_c.Call.Return(projects, v, err)
	return _c
}

func (_c *MockStorage_Projects_Call) RunAndReturn(run func(ctx context.Context, q string, limit uint64, offset uint64) ([]*storage.Project, uint64, error)) *MockStorage_Projects_Call {
	_c.Call.Return(run)
	return _c
}

// Release provides a mock function for the type MockStorage
func (_mock *MockStorage) Release(ctx context.Context, envID uint64, releaseName string) (*storage.Release, error) {
	ret := _mock.Called(ctx, envID, releaseName)

	if len(ret) == 0 {
		panic("no return value specified for Release")
	}

	var r0 *storage.Release
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) (*storage.Release, error)); ok {
		return returnFunc(ctx, envID, releaseName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) *storage.Release); ok {
		r0 = returnFunc(ctx, envID, releaseName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.Release)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, string) error); ok {
		r1 = returnFunc(ctx, envID, releaseName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Release_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Release'
type MockStorage_Release_Call struct {
	*mock.Call
}

// Release is a helper method to define mock.On call
//   - ctx context.Context
//   - envID uint64
//   - releaseName string
func (_e *MockStorage_Expecter) Release(ctx interface{}, envID interface{}, releaseName interface{}) *MockStorage_Release_Call {
	return &MockStorage_Release_Call{Call: _e.mock.On("Release", ctx, envID, releaseName)}
}

func (_c *MockStorage_Release_Call) Run(run func(ctx context.Context, envID uint64, releaseName string)) *MockStorage_Release_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_Release_Call) Return(release *storage.Release, err error) *MockStorage_Release_Call {
	_c.Call.Return(release, err)
	return _c
}

func (_c *MockStorage_Release_Call) RunAndReturn(run func(ctx context.Context, envID uint64, releaseName string) (*storage.Release, error)) *MockStorage_Release_Call {
	_c.Call.Return(run)
	return _c
}

// Releases provides a mock function for the type MockStorage
func (_mock *MockStorage) Releases(ctx context.Context, projectName string, envName string) ([]*storage.Release, error) {
	ret := _mock.Called(ctx, projectName, envName)

	if len(ret) == 0 {
		panic("no return value specified for Releases")
	}

	var r0 []*storage.Release
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) ([]*storage.Release, error)); ok {
		return returnFunc(ctx, projectName, envName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) []*storage.Release); ok {
		r0 = returnFunc(ctx, projectName, envName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.Release)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, projectName, envName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Releases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Releases'
type MockStorage_Releases_Call struct {
	*mock.Call
}

// Releases is a helper method to define mock.On call
//   - ctx context.Context
//   - projectName string
//   - envName string
func (_e *MockStorage_Expecter) Releases(ctx interface{}, projectName interface{}, envName interface{}) *MockStorage_Releases_Call {
	return &MockStorage_Releases_Call{Call: _e.mock.On("Releases", ctx, projectName, envName)}
}

func (_c *MockStorage_Releases_Call) Run(run func(ctx context.Context, projectName string, envName string)) *MockStorage_Releases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_Releases_Call) Return(releases []*storage.Release, err error) *MockStorage_Releases_Call {
	_c.Call.Return(releases, err)
	return _c
}

func (_c *MockStorage_Releases_Call) RunAndReturn(run func(ctx context.Context, projectName string, envName string) ([]*storage.Release, error)) *MockStorage_Releases_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function for the type MockStorage
func (_mock *MockStorage) UpdateProject(ctx context.Context, project *storage.Project) error {
	ret := _mock.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *storage.Project) error); ok {
		r0 = returnFunc(ctx, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type MockStorage_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *storage.Project
func (_e *MockStorage_Expecter) UpdateProject(ctx interface{}, project interface{}) *MockStorage_UpdateProject_Call {
	return &MockStorage_UpdateProject_Call{Call: _e.mock.On("UpdateProject", ctx, project)}
}

func (_c *MockStorage_UpdateProject_Call) Run(run func(ctx context.Context, project *storage.Project)) *MockStorage_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *storage.Project
		if args[1] != nil {
			arg1 = args[1].(*storage.Project)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_UpdateProject_Call) Return(err error) *MockStorage_UpdateProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_UpdateProject_Call) RunAndReturn(run func(ctx context.Context, project *storage.Project) error) *MockStorage_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type MockStorage
func (_mock *MockStorage) UpdateUser(ctx context.Context, id uint64, user *storage.User) error {
	ret := _mock.Called(ctx, id, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, *storage.User) error); ok {
		r0 = returnFunc(ctx, id, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockStorage_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint64
//   - user *storage.User
func (_e *MockStorage_Expecter) UpdateUser(ctx interface{}, id interface{}, user interface{}) *MockStorage_UpdateUser_Call {
	return &MockStorage_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, id, user)}
}

func (_c *MockStorage_UpdateUser_Call) Run(run func(ctx context.Context, id uint64, user *storage.User)) *MockStorage_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 *storage.User
		if args[2] != nil {
			arg2 = args[2].(*storage.User)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_UpdateUser_Call) Return(err error) *MockStorage_UpdateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_UpdateUser_Call) RunAndReturn(run func(ctx context.Context, id uint64, user *storage.User) error) *MockStorage_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertConfigs provides a mock function for the type MockStorage
func (_mock *MockStorage) UpsertConfigs(ctx context.Context, configs []*storage.Config) error {
	ret := _mock.Called(ctx, configs)

	if len(ret) == 0 {
		panic("no return value specified for UpsertConfigs")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*storage.Config) error); ok {
		r0 = returnFunc(ctx, configs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_UpsertConfigs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertConfigs'
type MockStorage_UpsertConfigs_Call struct {
	*mock.Call
}

// UpsertConfigs is a helper method to define mock.On call
//   - ctx context.Context
//   - configs []*storage.Config
func (_e *MockStorage_Expecter) UpsertConfigs(ctx interface{}, configs interface{}) *MockStorage_UpsertConfigs_Call {
	return &MockStorage_UpsertConfigs_Call{Call: _e.mock.On("UpsertConfigs", ctx, configs)}
}

func (_c *MockStorage_UpsertConfigs_Call) Run(run func(ctx context.Context, configs []*storage.Config)) *MockStorage_UpsertConfigs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*storage.Config
		if args[1] != nil {
			arg1 = args[1].([]*storage.Config)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_UpsertConfigs_Call) Return(err error) *MockStorage_UpsertConfigs_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_UpsertConfigs_Call) RunAndReturn(run func(ctx context.Context, configs []*storage.Config) error) *MockStorage_UpsertConfigs_Call {
	_c.Call.Return(run)
	return _c
}

// User provides a mock function for the type MockStorage
func (_mock *MockStorage) User(ctx context.Context, username string) (*storage.User, error) {
	ret := _mock.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 *storage.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*storage.User, error)); ok {
		return returnFunc(ctx, username)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *storage.User); ok {
		r0 = returnFunc(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storage.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, username)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_User_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'User'
type MockStorage_User_Call struct {
	*mock.Call
}

// User is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockStorage_Expecter) User(ctx interface{}, username interface{}) *MockStorage_User_Call {
	return &MockStorage_User_Call{Call: _e.mock.On("User", ctx, username)}
}

func (_c *MockStorage_User_Call) Run(run func(ctx context.Context, username string)) *MockStorage_User_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_User_Call) Return(user *storage.User, err error) *MockStorage_User_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockStorage_User_Call) RunAndReturn(run func(ctx context.Context, username string) (*storage.User, error)) *MockStorage_User_Call {
	_c.Call.Return(run)
	return _c
}

// Users provides a mock function for the type MockStorage
func (_mock *MockStorage) Users(ctx context.Context, q string, limit uint64, offset uint64) ([]*storage.User, uint64, error) {
	ret := _mock.Called(ctx, q, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for Users")
	}

	var r0 []*storage.User
	var r1 uint64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64) ([]*storage.User, uint64, error)); ok {
		return returnFunc(ctx, q, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, uint64) []*storage.User); ok {
		r0 = returnFunc(ctx, q, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*storage.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint64, uint64) uint64); ok {
		r1 = returnFunc(ctx, q, limit, offset)
	} else {
		r1 = ret.Get(1).(uint64)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, uint64, uint64) error); ok {
		r2 = returnFunc(ctx, q, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStorage_Users_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Users'
type MockStorage_Users_Call struct {
	*mock.Call
}

// Users is a helper method to define mock.On call
//   - ctx context.Context
//   - q string
//   - limit uint64
//   - offset uint64
func (_e *MockStorage_Expecter) Users(ctx interface{}, q interface{}, limit interface{}, offset interface{}) *MockStorage_Users_Call {
	return &MockStorage_Users_Call{Call: _e.mock.On("Users", ctx, q, limit, offset)}
}

func (_c *MockStorage_Users_Call) Run(run func(ctx context.Context, q string, limit uint64, offset uint64)) *MockStorage_Users_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_Users_Call) Return(users []*storage.User, v uint64, err error) *MockStorage_Users_Call {
	_c.Call.Return(users, v, err)
	return _c
}

func (_c *MockStorage_Users_Call) RunAndReturn(run func(ctx context.Context, q string, limit uint64, offset uint64) ([]*storage.User, uint64, error)) *MockStorage_Users_Call {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function for the type MockStorage
func (_mock *MockStorage) WithTransaction(ctx context.Context, f func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, f)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, f)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type MockStorage_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - f func(ctx context.Context) error
func (_e *MockStorage_Expecter) WithTransaction(ctx interface{}, f interface{}) *MockStorage_WithTransaction_Call {
	return &MockStorage_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, f)}
}

func (_c *MockStorage_WithTransaction_Call) Run(run func(ctx context.Context, f func(ctx context.Context) error)) *MockStorage_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_WithTransaction_Call) Return(err error) *MockStorage_WithTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_WithTransaction_Call) RunAndReturn(run func(ctx context.Context, f func(ctx context.Context) error) error) *MockStorage_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}
