package generator

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"text/template"
)

const (
	defaultTemplate = `// Code generated by "const generator". DO NOT EDIT.
package config

import (
	"rtc/pkg/rtc"
)

const (
	{{- range . }}
	/* {{ .Description }} */
	{{ .Key | toPascal }} = rtc.Key("{{ .Key }}")
	{{- end }}
)
`
	defaultTargetPath = "internal/config/config.go"
)

// Parser ...
type Parser interface {
	Parse([]byte) ([]*Config, error)
}

// Generator ...
type Generator struct {
	parser     Parser
	template   *template.Template
	targetPath string
}

// New ...
func New(parser Parser, options ...OptionFunc) *Generator {
	g := &Generator{
		parser:     parser,
		template:   template.Must(ParseWithFunctions(defaultTemplate)),
		targetPath: defaultTargetPath,
	}

	for _, option := range options {
		option(g)
	}

	return g
}

// Generate ...
func (g *Generator) Generate(filePath string) error {
	data, err := os.ReadFile(filePath) // nolint:gosec
	if err != nil {
		return fmt.Errorf("os.ReadFile %s: %w", filePath, err)
	}

	configs, err := g.parser.Parse(data)
	if err != nil {
		return fmt.Errorf("parser.Parse: %w", err)
	}

	var buf bytes.Buffer
	if err := g.template.Execute(&buf, configs); err != nil {
		return fmt.Errorf("template.Execute: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(g.targetPath), 0750); err != nil {
		return fmt.Errorf("os.MkdirAll: %w", err)
	}

	file, err := os.Create(g.targetPath)
	if err != nil {
		return fmt.Errorf("os.Create: %w", err)
	}
	defer file.Close()

	if _, err := io.Copy(file, &buf); err != nil {
		return fmt.Errorf("io.Copy: %w", err)
	}

	return nil
}
